# 算法

2024年9月7日 叶茂林

#### 快速排序

[快速排序 C C++ 递归实现_c语言从大到小排序效率较高的算法-CSDN博客](https://blog.csdn.net/weixin_62264287/article/details/122871477?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22122871477%22%2C%22source%22%3A%22weixin_62264287%22%7D)

#### 快速选择

在快速排序中每一轮交换元素过后都可以确定枢纽元素的排序位置，而我们需要寻找第K大的元素，通过记录枢纽元素两边元素的长度可以知道第K大的元素在那一边，因此只需要继续递归一边进行快排，直到枢纽元素的位置是第K个

#### 排序复杂度

| 排序方法     | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度  | 稳定性 | 复杂性 |
| ------------ | ---------------- | ---------------- | ---------------- | ----------- | ------ | ------ |
| 直接插入排序 | O(n^2^)          | O(n^2^)          | O(n)             | O(1)        | 稳定   | 简单   |
| 希尔排序     | O(nlog~2~n)     | O(n^2^)          | O(n^1.3^)        | O(1)        | 不稳定 | 较复杂 |
| 直接选择排序 | O(n^2^)          | O(n^2^)          | O(n^2^)          | O(1)        | 不稳定 | 简单   |
| 堆排序       | O(nlog~2~n)     | O(nlog~2~n)     | O(nlog~2~n)     | O(1)        | 不稳定 | 较复杂 |
| 冒泡排序     | O(n^2^)          | O(n^2^)          | O(n)             | O(1)        | 稳定   | 简单   |
| 快速排序     | O(nlog~2~n)     | O(n^2^)          | O(nlog~2~n)     | O(log~2~n) | 不稳定 | 较复杂 |
| 归并排序     | O(nlog~2~n)     | O(nlog~2~n)     | O(nlog~2~n)     | O(n)        | 稳定   | 较复杂 |
| 基数排序     | O(d(n+r))        | O(d(n+r))        | O(d(n+r))        | O(n+r)      | 稳定   | 较复杂 |

只有插入、冒泡、归并、基数是稳定的

#### 非递归遍历二叉树

前序遍历：根节点入栈，弹栈顶节点访问，先入栈右子节点，再入栈左子节点

中序遍历：将节点的所有左子节点入栈，弹栈顶节点访问，继续处理右节点

后序遍历：根节点入A栈，弹A栈节点入B栈，先将左子节点入A栈，再将右子节点入A栈，最后访问B栈

#### 单源最短路径

在有向加权图中找到从特定单源顶点到所有其它顶点的最短路径权重（和实际路径）（如果这样的路径存在）

##### 迪杰斯特拉

首先初始化单源顶点到其他所有顶点的距离为无穷大，然后从单源顶点出发，比较可以到达的顶点的距离，选出最短距离的一个顶点，该距离就是这两个顶点之间的最短距离，因为这个距离是目前可以到达的最短距离，后续就算有新的路径可以到达该点，路径的长度也是在这个最短距离上累加，然后以这个找到的新顶点为源点，寻找新的可以到达的顶点并更新到达该顶点的最短距离，再选出最短距离的一个顶点，反复操作下去知道找到所有顶点的最短路径

#### 最小生成树

无向图生成树中所有边权重和最小的树

##### Prim算法

从一个初始顶点出发，每次选择与当前生成树相邻并且权值最小的边的顶点加入生成树

##### 克鲁斯卡尔算法

每次选择图里面权值最小的边的两个顶点加入生成树，并且这两个点不在同一个连通分量，使用并查集维护连通分量，用数组记录每个顶点的连通分量索引（首个进来的顶点索引），合并连通分量的时候只需要把一个连通分量的索引改成另一个连通分量的索引即可，可以递归找到顶点所属的连通分量索引，递归结束条件是当前顶点的索引等于所属连通分量索引
