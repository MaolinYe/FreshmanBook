算法
=
---
叶茂林 2024年3月24日星期日
## 快速排序
快速排序递归算法使用双指针，有两种走法，假设枢纽元素取第一个，从小到大排序。  
一种是一个指针先走，利用枢纽元素空出来的位置填充找到的比它小的，接着另一个指针走动，利用刚刚填充空出来的位置填充找到的比枢纽元素大的，最后两个指针相同时填充上枢纽元素。
```c++
void QS(int*a,int low,int high){ // 一指针先走，一指针后走
    if(low>=high)
        return;
    int pivot=a[low],i=low,j=high;
    while(i!=j){
        while(i<j&&a[j]>=pivot) // 右指针找小的
            j--;
        if(i<j) // 把小的放到枢纽位置
            a[i++]=a[j];
        while(i<j&&a[i]<=pivot) // 左指针找大的
            i++;
        if(i<j) // 把大的放到空出来的位置
            a[j--]=a[i];
    }
    a[i]=pivot; // 放置枢纽元素
    QS(a, low, i - 1);// 继续排左边
    QS(a, j + 1, high);// 继续排右边
}
```
还有一种是两个指针同时走，左指针找到大的，右指针找到小的，然后交换这两个元素的位置，问题在于枢纽元素和谁交换，让右指针先走，两个指针走到相同位置的时候必然是右指针走到左指针的地方了，而左指针指向的元素是刚刚交换完比枢纽元素小的，而枢纽元素选的是第一个，因此它们进行位置交换就是正确的。
```c++
void QS(int *a, int low, int high) { // 两个指针同时走
    if (low >= high)
        return;
    int pivot = a[low], i = low, j = high;
    while (i != j) {
        while (i < j && a[j] >= pivot) // 右指针找小的
            j--;
        while (i < j && a[i] <= pivot) // 左指针找大的
            i++;
        if(i<j)
            std::swap(a[i],a[j]);
    }
    a[low]=a[i]; // 腾位置给枢纽元素
    a[i] = pivot; // 放置枢纽元素
    QS(a, low, i - 1);// 继续排左边
    QS(a, j + 1, high);// 继续排右边
}
```
## 快速选择
在快速排序中每一轮交换元素过后都可以确定枢纽元素的排序位置，而我们需要寻找第K大的元素，通过记录枢纽元素两边元素的长度可以知道第K大的元素在那一边，因此只需要继续递归一边进行快排，直到枢纽元素的位置是第K个