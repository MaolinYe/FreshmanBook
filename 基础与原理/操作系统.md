# 操作系统

2024年9月5日 叶茂林

### 基本知识

#### 为什么需要补码

补码表示负数可以直接运算

#### 局部性原理

时间局部性：最近访问的内存不久后可能还会被访问

空间局部性：当前访问的内存附近的内存不久后可能会被访问

#### 中断

硬中断：先让CPU停下当前的任务，快速响应中断请求，发出软中断请求

软中断：内核线程继续完成中断后要做的事情

### 进程

#### 进程和线程区别

创建和销毁、内存占用、切换

进程是程序运行的实例，在Linux上，进程和线程的基本数据结构都是一样的，都是用task结构体实现的，不过创建线程会和父进程共享打开的文件集合和虚拟地址空间

#### 进程切换开销

寄存器状态的保存和加载（程序计数器、栈指针、通用寄存器）

CPU多级缓存更新

页表和快表更新

进程调度

#### 线程切换开销

同一进程的线程切换开销比进程切换小一些，因为线程之间共享很多资源

#### 进程调度

##### 先来先服务

按照请求顺序进行调度

##### 短作业优先

预估执行时间短的先执行，如果是抢占式变成最短剩余时间优先

##### 高响应比优先

考虑响应时间和执行时间的比值，响应时间就是等待时间和执行时间之和

##### 优先级调度

优先级高的先执行

##### 时间片轮转

按照先来先服务排成就绪队列，让队首执行一个时间片的时间后中断送往队尾

#### 进程状态

调度的时候：执行、就绪

IO资源需求：阻塞

挂起激活：活动（就绪、阻塞），静止（就绪、阻塞）

创建、终止

#### 孤儿进程

父进程已经终止，而该进程仍然继续运行，会被操作系统的init进程（通常是进程ID为1的进程）收养，以确保它能够正常结束并释放资源

#### 僵尸进程

子进程结束父进程没有捕获它的退出状态，子进程变成僵尸进程

#### 管程

定义公共数据结构为并发进程执行的一组操作，进程调用管程访问临界资源

#### 临界资源

同一时刻只能有一个进程使用的资源

#### 临界区

进程中访问临界资源的代码段

#### 守护进程

后台运行的独立于终端的进程

##### 创建守护进程

后台运行程序，创建子进程后结束父进程，调用setsid创建新对话期成为会话组长脱离原终端、原进程组和登陆会话，再次创建子进程退出父进程卸任会话组长，这样就无法打开终端，关闭文件描述符，将当前目录改为根目录，将屏蔽字清零，忽略SIGCHLD信号避免产生僵尸进程

##### 多级反馈队列

准备多个就绪队列，每个队列优先级不同，第一个队列优先级最高，其余队列优先级逐个降低，每个队列时间片大小也不同，后一个队列时间片是前一个的两倍，每个队列采用先来先服务调度，如果进程可以在当前队列的一个时间片内完成就离开，不能完成就进入下一个队列的末尾

### 虚拟内存

在逻辑上扩充物理内存，磁盘上划分一块区域作为内存交换区，当内存物理页满时置换出物理页到内存交换区上

#### 虚拟内存地址

程序使用的内存地址

#### 物理内存地址

实际存在内存条里面的硬件空间地址

#### 逻辑地址到物理地址的转换

页内地址和物理块内的地址一一对应，地址转换只需要将页号转换为物理块号，通过页表完成，页表里面记录了从页号到物理块号的地址映射

由于地址转换的频率非常高，页表的功能需要通过硬件来实现，系统中设置了一个页表寄存器，存放页表在内存中的起始地址和页表的长度

当进程没有执行的时候，页表的起始地址和页表的长度存放在PCB里面，当进程进入执行状态的时候，页表的起始地址和页表长度被装进页表寄存器里面

当程序访问逻辑地址的数据的时候，逻辑地址会被分为页号和页内地址偏移两部分，先把页号和页表长度作比较，如果页号大于等于页表长度，说明本次访问越界，如果没有越界，以页号为索引，页表起始地址为基址找到页号对应的物理块号，再和页内地址组合得到物理地址

#### 快表

没有快表之前，程序访问逻辑地址的数据需要两次访问内存，第一次访问内存中的页表得到物理块号，再和页内偏移地址拼接得到物理地址，以此地址第二次访问内存才得到数据

因此在原来的基础上增加了一个高速缓存寄存器，存放着最近访问过的页表项，地址变换的时候先在快表里面找看看有没有，有的话直接读取页号对应的物理块号，没有再去内存里面的页表里面找到，然后往快表里面添加新的页表项，如果快表里面满了，就去掉一个最少访问的页表项，类似于LRU缓存

#### 页面置换

最佳页面置换（最长时间不使用）、先进先出、最近最久未使用、Clock置换、改良版clock置换

##### Clock置换

循环查找页面，换出未访问的页面，将扫描过程中已访问的页面标记为未访问

##### 改良版clock置换

设置访问位和修改位，循环查找页面，换出未修改未访问的页面，没有则换出未访问已修改的页面并将扫描过程中访问过的页面标记为未访问

### 堆栈内存分区有什么区别？

栈空间由编译器分配和回收，用来存放局部变量和函数参数，是一块连续的空间，由高地址向低地址扩展

堆空间需要手动分配和回收，不连续空间，链表管理，从低地址向高地址扩展

### 字节序

#### 大端序

高位字节放在内存的低地址

TCP/IP网络序

#### 小端序

低位字节放在内存的低地址

x86架构

### 锁

#### 自旋锁和互斥锁

互斥锁：独占锁，加锁失败的时候线程切换

自旋锁：加锁失败的时候等待锁可用

当被锁住的代码执行时间短于切换线程的时间时使用自旋锁

#### 悲观锁和乐观锁

悲观锁：修改共享资源先加锁

乐观锁：先让修改共享资源，再判断是否冲突，冲突修改失败

在线文档多人同时编辑：提交修改时比较版本号，不同则修改失败，相同则更新服务器版本号

#### 死锁

多个进程因为竞争资源造成的僵局

#### 死锁产生的原因

多个进程请求临界资源

进程在申请新资源的时候保持了旧资源

进程已获得的资源不会被其他进程剥夺

多个进程竞争不可剥夺资源，互相等待资源，形成环路等待

#### 解决死锁

忽略死锁、预防死锁、避免死锁、检测与解除死锁

#### 忽略死锁

当死锁影响不大，或者发生死锁的概率很低，可以不管它

#### 预防死锁（在分配资源前破坏死锁发生的条件）

一次性申请所有需要的资源、申请新资源失败释放旧资源、有序申请资源

#### 死锁避免（在分配资源时避免发生死锁）

迪杰斯特拉银行家算法，通过预判资源分配的安全性来防止进入不安全状态，进程请求资源时先试探性分配，即计算请求是否合理，资源是否足够分配

#### 死锁检测与解除

检测死锁寻找循环等待的资源分配链，剥夺资源、撤销进程

### 操作系统四大功能

处理机管理、存储器管理、设备管理功能、文件管理

#### 处理机管理

进程控制、进程同步、进程通信、作业调度和进程调度

#### 存储器管理

内存分配、内存保护、地址映射、虚拟内存

#### 设备管理

缓存管理、设备分配、设备管理

#### 文件管理

文件存储空间管理、目录管理、文件读写管理、文件共享保护

### 磁盘

#### 磁盘调度

先来先服务、最短寻道优先（最近磁道）、扫描（一直向外然后向内）、循环扫描（一直向外然后最内
