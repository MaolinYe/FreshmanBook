# Linux网络

2024年9月5日 叶茂林

#### 知识链接

#### 基本知识

Linux网络字节序是大端序

#### 内核是如何接收网络包的

网卡会关联内存上的一个ringbuffer（RX接收队列，指针数组，指向一堆skb结构体），数据帧从网线到达网卡时，DMA引擎会将数据帧DMA到ringbuffer上，如果满了就会丢弃数据包，DMA完成后会向CPU发起硬中断，CPU会调用网卡启动时注册的中断处理函数，发起软中断请求，让内核线程处理软中断，将skb从ringbuffer上取下来，申请新的skb挂上去，合并小包成大包，送往协议栈处理

#### 内核是如何发送网络包的

发送网络包会调用sendto系统调用，将数据传给协议栈处理，在协议栈中内核会申请一个skb，将数据拷贝进去，按照协议设置对应的TCP或UDP头，如果是TCP的话，会在进入网络层之前再克隆一个skb，因为最后skb会释放掉，而TCP需要支持重传，在收到对应的ACK前不会释放原始的skb，进入IP网络层会将路由表地址放进skb中，设置IP头，如果数据大于MTU会进行分片（将skb拷贝成多个skb，分片丢失整个包需要重传），然后由邻居子系统发出ARP请求获取目标MAC地址，最后如果系统态配额用尽会使用软中断内核线程发送，如果没有则使用用户进程内核态发送，将skb挂在ringbuffer上，然后构造DMA映射，由网卡发送出去

#### 零拷贝

如果数据是新读取的，那么读取磁盘上的数据需要DMA到PageCache中，然后从PageCache拷贝到用户内存，再拷贝到发送缓冲区，系统调用sendfile直接将数据从PageCache中拷贝到发送缓冲区里面

#### TCP三次握手

服务端需要绑定一个网络地址和一个监听端口，然后初始化全连接队列（链表）和半连接队列（哈希表），客户端根据不重复四元组找到一个可用的端口，然后生成初始序列号ISN发出SYN请求启动重传定时器，内核发送网络包到服务端接收网络包

服务端拿到握手包先判断半连接队列是否满了，如果满了且没开启tcp_syncookies会丢弃数据包，接着判断全连接队列是否满了，如果满了且还存在没处理完的半连接请求，丢弃数据包，如果都没有生成初始序列号构造SYNACK包发送，然后将连接添加到半连接队列，启动重传定时器

客户端响应服务端的SYNACK包，清除重传定时器，开启保活定时器，发出第三次握手的ack确认

服务端响应第三次握手包会在半连接队列里面查找对应的连接，判断全连接队列是否满，满了就丢弃，不满就从半连接队列里面删除连接，将连接插入全连接队列链表尾部，当连接被使用的时候会从全连接队列里面取走

tcp_syncookies是Linux内核中的一个参数，用于防止SYN洪水攻击，当tcp_syncookies被启用时，服务器在半连接队列满时，会响应客户端的SYN请求，而不是直接丢弃请求

#### 服务器能支持多少TCP连接

首先是能打开的最大文件数有系统级、用户级和进程级的参数限制

然后是TCP连接是由四元组区分的，源地址、源端口、目的地址和目的端口有一个不同都是一条不同的连接，服务器的源地址和源端口一般是固定的，能么理论上可以支持的TCP连接数量是地址数乘以端口数，200多万亿

先考虑空连接，一条TCP空连接占内存3KB，如果是4GB的内存可以维持100万的空连接，所以最大连接数量受限于内存

但如果有数据传输，那么需要进行内核协议栈的处理，会消耗更多的内存

#### 客户端能支持多少TCP连接

客户端除了有最大可打开文件数限制外，还有可用端口的限制，因为在服务器IP地址和端口固定的情况下，客户端每连接一个TCP都需要消耗一个端口，Linux默认开启3万多个可用端口，通过修改，除开一些默认保留使用的端口，可以开启6万四千个端口，然后通过配置本机额外的IP可以增加连接的上限，当然还能连接不同的服务器和端口增加，最大连接数量还是受限于内存
