# C++

2024年9月4日 叶茂林

#### 知识链接

[从4行代码看右值引用 - qicosmos(江南) - 博客园 (cnblogs.com)](https://www.cnblogs.com/qicosmos/p/4283455.html)

### 基本语法

面向对象的三大特性：封装、继承、多态

常量对象只能调用常量函数

静态成员变量只能在定义类的时候初始化或者在类外部初始化

#### 参数初始化列表

与在函数体初始化相比，参数初始化列表是初始化，函数体内是赋值，可以初始化const和引用成员

#### printf的问题

传入参数的顺序不能确定

强行按照格式控制读取内存栈上的数据

#### 程序编译过程

预处理：处理预编译命令、展开宏定义

编译：根据语法生成汇编代码

汇编：变成机器码

链接：静态链接、动态链接

静态链接：编译时所有被调用到的函数和库的代码全部被复制到可执行文件中

动态链接：编译时可执行文件只包含被调用的库函数的引用，实际的库函数代码存放在共享库中

#### 构造顺序

先构造基类，然后按照声明的顺序（即使在初始化列表中顺序不同）构造成员变量，最后构造本类

#### 成员函数，const在前面在后面有什么区别

Const在前面是表示函数返回值是一个常量类型，不能被修改

Const在后面表示函数不能修改成员变量

#### Static

使变量具有静态持续时间，在程序启动时分配，在程序结束时释放，只会被初始化一次

使类成员变量被类所有实例共享同一个副本

使类成员函数可以通过类名调用

#### 静态成员函数

没有this指针，只能访问静态成员函数和静态成员变量

#### 空类的大小

1字节，要寻址，类实例的内存地址不能相同

#### it++和++it

it++返回临时对象，++it返回引用

#### 类的默认成员函数

构造函数

析构函数

拷贝构造函数

重载赋值运算符函数

移动构造函数

重载移动赋值运算符函数

重载取地址运算符函数

重载取地址运算符常量函数

#### 多继承、多重继承

多继承：一个子类同时继承多个父类

多重继承：多层继承关系

#### C和C++有什么区别？

C和C++在一般语句上没有什么区别，但是基本上属于两种编程语言，C++有新增的语法和关键字，增加了命名空间，管理内存方面增加了new和delete，在指针的基础上增加了引用，增加函数重载和模板实现了静态多态，提供了STL标准容器库

相对于C的结构体，C++增加了用于实现面向对象的类，出现了成员函数，并且提供了访问权限的控制，并在此基础上通过继承和虚函数实现了动态多态

#### C++和Java有什么区别？

Java没有指针，而C++允许通过指针操纵内存

Java不支持多继承，但Java有接口，可以通过一个类继承多个接口来达到C++多继承的效果

Java是完全面向对象的语言，所有的函数和变量都必须是某个类的成员

Java有垃圾回收机制可以自动回收无用内存，C++则要通过智能指针才能实现内存自动回收

### 指针和引用

#### 指针和引用的区别

指针本质是一个变量，这个变量里面存储的是某个变量的内存地址，而引用是一个已经存在的变量的别名，具体反映在编译的时候它们两个的符号表的值是不一样的，指针符号对应的值是这个指针变量的地址，而引用符号对应的是引用变量的地址，所以这个指针是可以为空的，因为它本质是一个变量，但是引用不能为空，它的存在必须依赖于已经存在的变量。

#### 指针传参和引用传参的区别

先解释指针和引用的区别，虽然两种传参都可以修改实参，但是指针传参实际还是值传递，将变量的地址传递到参数上，而引用传参直接传递参数本身，并且这个指针传参可以传空指针，但是引用传参不能传空引用，而且在函数内部修改指针参数不会对外部指针造成影响

#### 野指针和悬空指针

野指针是未初始化的指针，悬空指针是指向已释放的内存空间的指针，使用野指针和悬空指针会导致未定义的行为

#### 左值引用和右值引用

左值：有名字的可寻址的变量

纯右值：非引用返回的临时变量、运算表达式、常量、lambda表达式

将亡值：被移动的对象、返回右值引用的函数返回值、move返回值

#### 右值引用

解决临时对象的非必要拷贝（移动语义），解决模板函数中按照参数类型进行转发（完美转发）

#### 移动构造、移动语义

当用一个对象初始化另一个对象的时候匹配的是拷贝构造函数，为了安全和不改变其他对象会使用深复制，但是如果是用临时对象（函数返回值）构造新对象的时候会进行不必要的拷贝，

移动构造函数可以解决不必要的拷贝，移动构造函数通过右值引用来匹配临时值，用浅拷贝，复制指针的值，将资源转移过来，并将原对象的指针置为空

为了优化性能，也可以用move将左值转换为右值引用，然后匹配上移动构造函数

#### 完美转发

模板右值引用（T&&）是万能引用可以接受左值和右值，但是右值引用本身是左值，在函数传参过程中会被引用折叠为左值引用，通过C++11新引入的forward函数可以将参数原封不动的传递到下一个函数中，即保留了引用折叠前的参数的左右值属性

#### 引用折叠

右值引用叠加还是右值引用

其他引用叠加变成左值引用

### 多态

#### 多态的实现

多态分成静态多态和动态多态

静态多态（编译时多态，通过重载和模板实现）

动态多态（运行时多态，通过虚函数和继承实现）

#### 虚函数实现原理

通过在类的虚函数表中存储虚函数指针来实现，当调用虚函数时，实际上是通过对象的虚表指针找到对应的虚函数表，再根据函数在虚函数表中的索引找到对应的函数地址进行调用

#### 构造函数为什么不能写成虚函数

从实现角度来看，如果构造函数是虚函数，那么就需要通过虚表指针指向的虚函数表来调用，但是此时对象还没有实例化，还没有虚表指针，无法调用

从使用角度，构造函数只能是在创建对象的时候主动调用的，无法使用虚函数机制来调用

#### 析构函数为什么要写成虚函数

当使用指向派生类对象的基类指针来销毁对象的时候，如果析构函数不是虚函数，那么就只会调用基类的析构函数，而不会调用派生类的

#### 为什么需要多态

代码复用，可以用统一的方式处理不同的子类对象

### new delete malloc free

#### 区别

new和delete是C++的运算符，malloc和free是C的标准库里面的函数，malloc和free用来分配和释放内存，new和delete除了完成分配和释放内存还会自动调用对象的构造函数和析构函数。

从使用上来说，malloc需要指定分配的空间大小，以及返回的是void指针，而new不需要指定空间大小，返回的是具体类型指针

#### 为什么需要 new delete

Malloc和free是库函数不是运算符，new和delete可以被重载实现自定义内存分配

New可以自动计算所需要的内存空间，并自动调用构造函数初始化对象，delete会自动调用析构函数完成对象回收

#### new的可以free吗

没有语法错误，但是有逻辑错误，因为free不会调用析构函数

#### malloc的可以delete吗

没有语法错误，但是有严重的逻辑错误，因为delete会尝试调用对象的析构函数，而malloc分配的内存并没有构造对象，会出现未定义行为

#### 多次delete同一个对象会怎么样

Delete对象会调用对象的析构函数，释放内存，指向该对象的指针会变成悬空指针，如果不将悬空指针赋值为空指针的话，再次delete会出现未定义的行为

#### Delete空指针会怎么样？

Delete空指针是安全的，delete内部有对指针判空，不会怎么样

#### free/delete怎么知道要释放多大的内存

申请的内存块前面几个字节存储了内存块的大小

#### 内存溢出

申请的内存超过了可以提供的内存

#### 内存泄漏

内存没有及时释放，share指针相互引用导致析构的时候引用无法降为0无法释放资源

### 智能指针

#### auto_ptr

独占所有权的，只有一个指针指向资源，auto在转换资源所有权的时候是通过reset和release来重载赋值运算符实现的，先是release将原始指针赋值为空，然后reset将资源转换给新的指针，这个时候如果再使用原始指针访问资源就会出现访问空指针的问题，行为未定义

#### unique_ptr

独占式，禁用拷贝构造函数和赋值运算符，通过移动构造函数和移动赋值运算符转移资源所有权

#### Share_ptr

共享式，允许多个智能指针指向相同的资源，对资源引用进行计数，默认构造的时候引用计数初始化为1，拷贝构造的时候，引用计数在拷贝的基础上加一，赋值的时候原资源引用计数减一，新资源引用计数加一，当析构的时候会引用减一，引用为0的时候会释放资源。

然而当share指针相互引用的时候会出现析构的时候引用无法降为0的问题，weak_ptr就是用来解决这个问题的

#### weak_ptr

指向share指针管理的对象，只引用不计数

#### RAII

RAII（Resource Acquisition Is Initialization），将资源的获取与对象的生命周期绑定在一起，即在对象的构造函数中获取资源，在析构函数中释放资源

### 对齐

#### 结构体对齐

默认按最大成员对齐

C++11后可以用alignof得到对齐方式，alignas指定对齐方式，也可以用预处理命令#pragma pack(push,n)指定对齐方式，用pack(pop)恢复默认对齐方式

#### 为什么需要内存对齐

硬件平台原因：有些硬件不支持访问任意地址的内存

性能原因：CPU读写数据是按一块一块内存读取的，内存不对齐会导致有些数据处于内存读取的边界上，需要两次访问内存

#### 为什么需要禁用内存对齐

减小内存占用

通信协议，紧凑布局可以方便解析数据
